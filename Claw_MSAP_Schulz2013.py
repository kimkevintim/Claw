# Python script
# This script used to "CLAW" MSAP binary data from file [*_d_B.out] which generated by tinyFLP.
#	Frist make mean size from "Polymorphic peaks" as loci name to creat header of list. 
#	Separate data from MspI and HpaII in "Allelic matrix" according to custom character at 
#	sample name, and form two list respectively.
#	And generate a matrix to show new type of MSAP data which can assign M+/H+, M+/H-, M-/H+
#	and	M-/H- to the character defined by yourself.
#
#
# Histroy
#	2017/10/11	Ver.1	MSAP per epigenotuping follow by Schulz et al. 2013


import sys




input_file_name = sys.argv[1]	# without "_d_B.out"
out_file_name = sys.argv[2]
population_map = sys.argv[3]
#out_file_type = "txt" # csv as , and txt as tab
Pname = "P05" # primer name
Ptype = "B" # primer name at "F"ront or "B"ack of sample name
c_MspI = "M" # character at sample name which represent sample digested by MspI
c_HpaII = "H" # by HpaII

MpHp = "1" # character represent M+/H+
MpHn = "2" # M+/H-
MnHp = "3" # M-/H+
MnHn = "4" # M-/H-
#threshold_MAF = 0.0 # threshold for minor allele frequency from new MSAP dataset





def select_data(x):
	if len(x) > 1:
		if "Polymorphic" in x[0] and "peaks" in x[1]: return 1 # get header also "mean width"
		if "Allelic" in x[0] and "matrix" in x[1]: return 2 # get data also "0101"
		if "Sample" in x[0] and "peak" in x[1] and "statistics" in x[2]: return 3 # time to break

data_range = 0
data_header = ["Ind"]
data_MspI = []
data_HpaII = []

inf = open( input_file_name, "r")
for line in inf:
	line = line.split()
	
	if select_data(line) != None:
		data_range = select_data(line)
		
	if data_range == 1 and len(line) > 3 and "cnt" not in line[0] and "." not in line[0]:
		o_loci_name = line[3]
		loci_name = Pname + "_" + o_loci_name[:5].replace(".","")
		data_header.append(loci_name)
	
	if data_range == 2 and len(line) == 2 and "matrix" not in line:
		sample_name = line[0] # get sample names
		if Ptype == "B": data_ind = [sample_name[4:-(len(Pname)+2)]] # remove coordinate of well 
		if Ptype == "F": data_ind = [sample_name[4+(len(Pname)+2):]]
		for locus in list(line[1]): data_ind.append(locus) # turn locus from string to list
		if c_MspI in sample_name[4:]: data_MspI.append(data_ind)
		if c_HpaII in sample_name[4:]: data_HpaII.append(data_ind)

	if data_range == 3: break
inf.close()

import operator
data_MspI = sorted(data_MspI, key=operator.itemgetter(0))
data_HpaII = sorted(data_HpaII, key=operator.itemgetter(0))
data_MspI.insert(0, data_header)
data_HpaII.insert(0, data_header)




if len(data_MspI) == len(data_HpaII):
	for i in range(len(data_HpaII)-1):
		if data_MspI[i][0] != data_HpaII[i][0]:
			print("Samples are different between MspI and HpaII")
else: print("Number of samples are not equal between MspI and HpaII")

for i in data_MspI:
	if len(i) != len(data_header):
		print("Number of loci are not equal between samples!!!!!")
		sys.exit()
for i in data_HpaII:
	if len(i) != len(data_header):
		print("Number of loci are not equal between samples!!!!!")
		sys.exit()




print("\nFound " + str(len(data_HpaII)-1) + " samples:")
for i in range(len(data_HpaII)-1):
	print(data_HpaII[i+1][0] + "\t", end="")
print()

print("\nFound " + str(len(data_header)-1) + " loci:")
for i in range(len(data_header)-1):
	print(data_header[i+1] + "\t", end="")
print()




data_MH = []
for j in range(len(data_MspI)-1):
	data_MH_ind = [data_MspI[j+1][0]]
	for i in range(len(data_header)-1):
		if data_MspI[j+1][i+1] == "1" and data_HpaII[j+1][i+1] == "1": data_MH_ind.append(MpHp)
		if data_MspI[j+1][i+1] == "1" and data_HpaII[j+1][i+1] == "0": data_MH_ind.append(MpHn)
		if data_MspI[j+1][i+1] == "0" and data_HpaII[j+1][i+1] == "1": data_MH_ind.append(MnHp)
		if data_MspI[j+1][i+1] == "0" and data_HpaII[j+1][i+1] == "0": data_MH_ind.append(MnHn)
	data_MH.append(data_MH_ind)
data_MH.insert(0, data_header)
#print(data_MH)

name_eploci = []
#posi_eploci = []
for i in range(len(data_header)-1):
	eploci = []
	for j in range(len(data_MH)-1):
		eploci += data_MH[j+1][i+1]

	count_I = 0
	count_II = 0
	count_III = 0
	count_IV = 0
	for i in eploci:
		if i is "1": count_I += 1
		if i is "2": count_II += 1
		if i is "3": count_III += 1
		if i is "4": count_IV += 1

	if 	count_I > len(data_MH)-3 or count_II > len(data_MH)-3 or \
	 count_III > len(data_MH)-3 or count_IV > len(data_MH)-3:
		name_eploci.extend(data_header[j+1])
	
	
	#print(count_I, count_II, count_III, count_IV)


print("\nEpiloci that showed a monomorphic or deviation between EcoRI/MspI \
and EcoRI/HpaII in only one individual (haven't been remove):")	
print(name_eploci)
#print(posi_eploci)


'''
locus_below_MAF = []
AF_below_MAF = []
for j in range(len(data_header)-1):
	count_0 = 0
	count_1 = 0
	for i in range(len(data_MH)-1):
		if data_MH[i+1][j+1] == "0" : count_0 += 1
		if data_MH[i+1][j+1] == "1" : count_1 += 1
	#print("0: " + str(count_0))
	#print("1: " + str(count_1))
	if threshold_MAF > 0:
		if count_0 / (len(data_MH)-1) <= threshold_MAF: 
			locus_below_MAF.append(data_MH[0][j+1])
			AF_below_MAF.append(count_0 / (len(data_MH)-1))
			#print(data_MH[0][j+1], end="")
			#print(": " + str(count_0 / (len(data_MH)-1)))
		if count_1 / (len(data_MH)-1) <= threshold_MAF: 
			locus_below_MAF.append(data_MH[0][j+1])
			AF_below_MAF.append(count_0 / (len(data_MH)-1))
			#print(data_MH[0][j+1], end="")
			#print(": " + str(count_0 / (len(data_MH)-1)))
#print(locus_below_MAF)

print("\nRemove " + str(len(locus_below_MAF)) + \
" locus which allele frequency below threshold " + str(threshold_MAF) + " from new dataset:")
for i in range(len(locus_below_MAF)):
	print("  " + locus_below_MAF[i] + ": " + str(round(AF_below_MAF[i], 3)))

for i in locus_below_MAF:
	index_below_MAF = data_MH[0].index(i)
	for j in range(len(data_MH)): del data_MH[j][index_below_MAF]
		#print (str(j+1) + " : " + str(index_below_MAF))

print("\nNew MSAP dataset have formed by " + str(len(data_MH)-1) + " samples and " + \
str(len(data_MH[0])-1) + " locus")
'''

inpf = open(population_map, "r")
pop_map = []
for pop in inpf:
	pop = pop.split()
	pop_map.append(pop)

#print(pop_map)
	
sample_list = []
for j in range(len(data_MH)-1):
	sample_list.append(data_MH[j+1][0])
sample_map = []
for i in range(len(pop_map)):
	sample_map.append(pop_map[i][0])
#print(sample_map, len(sample_map))

sample_list_cheak = sample_list[:]
sample_map_cheak = sample_map[:]
#print(id(sample_list_cheak), id(sample_list))
#print(sample_map[142])

for k in range(len(sample_map)):
	if sample_map[k] in sample_list:
		#print(k)
		sample_map_cheak.remove(sample_map[k])
		sample_list_cheak.remove(sample_map[k])
	#if sample_map[k] not in sample_list: continue

if sample_list_cheak != [] and sample_map_cheak != []: 
	print('Warining message ! ! !')
	print('Samples from popmap did not found match to your data:')
	for i in sample_map_cheak: print(i)
	print('Samples from your data did not found match to popmap:')
	for i in sample_list_cheak: print(i)
	sys.exit()
else:
	print("\nSample ID cheak from popmap...  OK !!")
print(sample_list_cheak, sample_map_cheak)



if out_file_name[-3:] == "txt": out_type = "\t"
if out_file_name[-3:] == "csv": out_type = ","

outf = open(out_file_name, 'w')
data_header.insert(1, "EZ")
outf.write(out_type.join(data_header) + '\n')

for i in range(len(data_MH)-1):
	data_MspI[i+1].insert(1, "M")
	outf.write(out_type.join(data_MspI[i+1]) + '\n')
	data_HpaII[i+1].insert(1, "H")
	outf.write(out_type.join(data_HpaII[i+1]) + '\n')
outf.close()
print("\nOutputing... " + str(out_file_name) + "       DONE !!!")



